<html>
	<head>

	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/default.min.css">

	</head>

	<body>
		<h1> Relatório lab 1 </h1>

		<br>
		
		<h2> 1.Introdução </h2>
		
		<p>Este relatório descreve a atividade realizada com o objetivo de iniciar os trabalhos no Ubuntu com o OpenCV, uma biblioteca utilizada para processamento de imagens e vídeos. A atividade consistiu em explorar comandos básicos para visualização e gravação de imagens e vídeos, assim como realizar alterações nos programas fornecidos.</p>	
		
		<p>O relatório está organizado em três partes principais. Na primeira parte, foi realizada a preparação do ambiente de trabalho, seguindo as instruções fornecidas no Moodle e baixando os arquivos do Lab1 - Parte 1.</p>

		<p>Na segunda parte, focamos no processamento básico de imagens e vídeos. Foram disponibilizados quatro programas, nos quais estudamos diferentes operações e realizamos alterações solicitadas. Isso incluiu a leitura de imagens e vídeos a partir de arquivos, ajuste de velocidade de exibição, leitura de imagens da câmera e gravação de vídeos da câmera.</p>

		<p>A terceira parte envolveu a obtenção de fotos e vídeos com a webcam, utilizando os programas corrigidos da parte anterior. Foi solicitado que capturássemos uma foto geral do grupo, realizássemos uma montagem de avatares individuais e gravássemos vídeos com diferentes tipos de movimento.</p>

		<p>Ao longo deste relatório, serão apresentados os programas elaborados pela equipe para cada etapa, descrevendo as alterações realizadas e as soluções adotadas.</p>
		
		<br>
		<h2> 2.Fundamentos Básicos</h2>

		<p>Neste tópico, abordaremos os fundamentos básicos que foram utilizados durante as atividades realizadas. Esses conceitos são essenciais para compreender e explorar as funcionalidades do OpenCV, bem como realizar o processamento de imagens e vídeos.</p>

		<h3>a. Processamento de Imagens e Vídeos:</h3>

		<p>O processamento de imagens e vídeos refere-se às técnicas e algoritmos utilizados para modificar ou analisar esses tipos de mídia digital. O objetivo principal é extrair informações relevantes ou realizar melhorias nas imagens e vídeos, como ajuste de brilho, detecção de bordas, segmentação de objetos, entre outros.</p>

		<h3>b. Biblioteca OpenCV:</h3>

		<p>O OpenCV (Open Source Computer Vision Library) é uma biblioteca de código aberto amplamente utilizada para processamento de imagens e visão computacional. Ela oferece uma vasta gama de funções e algoritmos otimizados para realizar tarefas comuns nessa área, como leitura e gravação de imagens e vídeos, manipulação de pixels, detecção de objetos, entre outros.</p>

		<h3>c. Leitura e Gravação de Imagens:</h3>

		<p>A leitura de imagens envolve a extração dos dados contidos em um arquivo de imagem específico e sua representação na memória do computador. Já a gravação de imagens consiste em salvar uma imagem processada ou capturada em um arquivo. Essas operações são fundamentais para carregar imagens para processamento e salvar os resultados obtidos.</p>

		<h3>d. Leitura e Gravação de Vídeos:</h3>

		<p>A leitura de vídeos envolve a reprodução sequencial de uma sequência de imagens em alta velocidade, criando a ilusão de movimento. A gravação de vídeos, por sua vez, consiste em capturar e salvar essa sequência de imagens em um arquivo. Essas operações são utilizadas para processar e armazenar informações visuais dinâmicas.</p>

		<h3>e. Manipulação de Velocidade de Exibição:</h3>

		<p>A manipulação da velocidade de exibição de imagens ou vídeos está relacionada ao controle da taxa de quadros (frames per second - FPS) durante a reprodução. É possível ajustar essa taxa para aumentar ou diminuir a velocidade de exibição, resultando em uma reprodução mais rápida ou mais lenta das imagens ou vídeos.</p>

		<h3>f. Interação com a Câmera:</h3>

		<p>A interação com a câmera envolve a captura de imagens em tempo real por meio de dispositivos de câmera conectados ao computador. Isso permite a leitura de imagens da câmera em tempo real e a gravação de vídeos com base nessas imagens, abrindo possibilidades para aplicativos de visão computacional em tempo real.</p>

		<br>
		<h2> 3.Materiais e Métodos</h2>

		<h3>Diagrama de blocos funcional</h3>

		<h3>1. Ambiente dos experimentos</h3>

		<p>a) Sistema Operacional:</p>
		<p>- Ubuntu (versão 20.22)</p>

		<p>b) Equipamentos:</p>
		<p>- Computador com webcam integrada</p>
		<p>- Monitor de exibição</p>

		<h3>2. Programas e Bibliotecas utilizadas</h3>

		<p>a) Programas:</p>
		<p>- Python: Linguagem de programação utilizada para desenvolver os programas.</p>

		<p>b) Bibliotecas:</p>
		<p>- OpenCV (versão 4.7.0): Biblioteca principal para manipulação de imagens e vídeos.</p>
		<p>- NumPy (versão 1.21.5): Biblioteca para operações numéricas e processamento de arrays.</p>
		<p>- Time: Biblioteca para aumentar o tempo para tirar as fotos.</p>

		<h3>2. Softwares adicionais</h3>

		<p>a) Editor de Imagens:</p>
		<p>- </p>

		<br>
		<h2> 4.Resultados e Análises</h2>

		<h3> Parte 2A </h3>
		<h4> Código Original</h4>
		<pre><code class="python">
import numpy as np
import cv2 as cv

img = cv.imread('messi5.jpg',0)
cv.imshow('image',img)
k = cv.waitKey(0)
if k == 27:         # wait for ESC key to exit
    cv.destroyAllWindows()
elif k == ord('s'): # wait for 's' key to save and exit
    cv.imwrite('messigray.png',img)
    cv.destroyAllWindows()
		</code></pre>
		<p> O código acima le um arquivo de imagem e o exibe na tela.Depois, espera por um input do usuário para salvar a imagem ou fechar a janela</p>
		<p><b><br>Pergunta: Por que a janela aberta não mostra a imagem colorida?</b></p>
		<p>A imagem é lida do arquivo através da função cv.imread(), seu segundo argumento recebe uma flag que diz como a cor do arquivo deve ser interpretada. Essa flag possui 3 valores possíveis:
		<ul>
			<li>cv2.IMREAD_GRAYSCALE ou 0: Carrega a imagem em escala de cinza</li>
			<li>cv2.IMREAD_COLOR ou 1: Carrega apenas a cor da imagem, negligenciando a transparência</li>
			<li>cv2.IMREAD_UNCHANGED ou -1: Carrega a imagem sem nenhuma modificação</li>
		</ul> 
		Sendo assim, podemos concluir que janela aberta não mostra a imagem colorida porque o segundo parâmetro do cv.imread() é 0.
		Podemos corrigir esse comportamento alterando a linha correspondente no código.
		<pre><code class="python">
img = cv.imread('messi5.jpg',-1)
		</code></pre>
			<br><br><a href=https://github.com/CrakehallBoars/CrakehallBoars.github.io/blob/main/reports/report1/2A.py>Código Fonte Modificado</a>
		</p>
		<h3> Parte 2B </h3>
		<h4> Código Original</h4>
		<pre><code class="python">
import time
import numpy as np
import cv2 as cv

cap = cv.VideoCapture('big_buck_bunny.mp4')

while(cap.isOpened()):
    ret, frame = cap.read()
    
    if ret==True:
        # show the frame
        cv.imshow('frame',frame)

        #wait next frame by 40ms - 25fps
        time.sleep(1/25.0) 
        
        if cv.waitKey(1) & 0xFF == ord('q'):
            break
    else:
        break
cap.release()
cv.destroyAllWindows()
		</code></pre>
		<p> O Código acima le um arquivo de vídeo com a função cv.VideoCapture() (ela também poderia ser usada para ler o vídeo de uma câmera ou outra fonte).
			<br> Depois, vai exibir um frame de cada vez enquanto o usuário não fechar o programa apertando 'q'.
			O frame exibido na tela só é atualizado com a função cv.imshow(), como entre cada chamada dessa função o programa congela por meio da função time.sleep(), sendo seu arquivomento esse tempo em segundos, que no caso acima é de 40ms.
		</p>

		<br>
		<p> Reduzindo o valor do argumento da função sleep, as imagens são exibidas mais rapidamente. No código abaixo diminuimos o tempo entre as imagens para 10ms</p>
		<pre><code class="python">
        #wait next frame by 10ms - 100fps
        time.sleep(1/100.0) 
		</code></pre>
		<p> Aumentando o valor do argumento da função sleep, as imagens são exibidas mais lentamente. No código abaixo aumentamos o tempo entre as imagens para 100ms</p>
		<pre><code class="python">
        #wait next frame by 100ms - 10fps
        time.sleep(1/10.0) 
		</code></pre>
			<a href=https://github.com/CrakehallBoars/CrakehallBoars.github.io/blob/main/reports/report1/2B.py>Código Fonte Modificado</a>
		<h3> Parte 2C </h3>
		<h4> Código Original</h4>

		<pre><code class="python">
import numpy as np
import cv2 as cv

cap = cv.VideoCapture(0)

if not cap.isOpened():
    print("Cannot open camera")
    exit()
    
while True:
    # Capture frame-by-frame
    ret, frame = cap.read()
    # if frame is read correctly ret is True
    if not ret:
        print("Can't receive frame (stream end?). Exiting ...")
        break
    
    # Display the resulting frame
    cv.imshow('frame', frame)
    
    if cv.waitKey(1) == ord('q'):
        break

# When everything done, release the capture
cap.release()
cv.destroyAllWindows()
		</code></pre>
		<p> O código acima é análogo ao código original da Parte 2B, só difere em ler as imagens da câmera e não de um arquivo de vídeo.</p>

		<p>Para que este código salve imagens no arquivo "foto1.png" quando a tecla 'x' for apertada, basta adicionar as seguintes linhas de código dentro do while True:
		<pre><code class="python">
    if cv.waitKey(1) == ord('x'):
        cv.imwrite("foto1.png",img)
		</code></pre>
		Este if só será executado quando o usuário apertar a tecla x, e quando isso acontecer, vai usar a função cv.imwrite() para armazenar o frame atual lido na câmera no arquivo "foto1.png", primeiro argumento da função. </p>

	</p> Para coletar as imagens da Parte 3A, acabamos fazendo algumas adições extras neste programa.

		<pre><code class="python">
	    key = cv.waitKey(1) 
		</code></pre>
		A primeira consiste em armazenar o código ascii da tecla apertada(retorno da função waitKey(1)) na variavel key, para poder comparar posteriormente.

		<pre><code class="python">
    if(key != -1):
        time.sleep(5)
        ret, frame = cap.read()
        cv.imwrite(f"fotos/{key}.png", frame)
		</code></pre>

		A segunda consiste em sempre que uma tecla for apertada, esperar 5s, capturar um frame novo da camera novamente e salva-lo em um arquivo com o código ascii da tecla apertada(idealmente converteriamos para o caractere, mas não tivemos tempo). 
		Esse tempo extra nos permitia mover para a tela de gravação depois de apertar a tecla, que estava um pouco distante do computador. E salvar em um arquivo com o nome baseado na tecla nos permitia salvar imagens diferentes sem trabalho extra.

		<br><a href=https://github.com/CrakehallBoars/CrakehallBoars.github.io/blob/main/reports/report1/2C.py>Código Fonte Modificado</a>

		<h3> Parte 2D </h3>
		<h4> Código Original</h4>
		<pre><code class="python">
import numpy as np
import cv2 as cv
cap = cv.VideoCapture(0)

# Get current width of frame
width = cap.get(cv.CAP_PROP_FRAME_WIDTH)   # float
# Get current height of frame
height = cap.get(cv.CAP_PROP_FRAME_HEIGHT) # float
# Define Video Frame Rate in fps
fps = 10.0

# Define the codec and create VideoWriter object
fourcc = cv.VideoWriter_fourcc(*'XVID')
out = cv.VideoWriter('saida.avi', fourcc, fps, (int(width),int(height)) )

while cap.isOpened():
    ret, frame = cap.read()
    if not ret:
        print("Can't receive frame (stream end?). Exiting ...")
        break
    frame = cv.flip(frame, 0)
    # write the flipped frame
    out.write(frame)
    cv.imshow('frame', frame)
    if cv.waitKey(1) == ord('q'):
        break

# Release everything if job is finished
cap.release()
out.release()
cv.destroyAllWindows()
		</code></pre>

		<p> O código acima inicia a coneção com uma câmera, depois checa a resolução da mesma. Com os valores de resolução, cria um objeto cv.VideoWriter com o codec XVID para começar a salvar as imagens coletadas na câmera em um vídeo no formato AVI.
			Feito isso, vai inverter a imagem coletada da câmera ao longo do eixo X com a função cv.flip() todo frame até que a tecla 'q' seja pressionada e o programa seja finalizado.
			O Segundo argumento da função cv.flip() determina como a imagem passada como primeiro argumento será invertida com base nas seguintes regras:
		<ul>
			<li> 0: Rotação ao longo do eixo X</li>
			<li> >0: Valores positivos rotacionam ao longo do eixo Y</li>
			<li> &lt;0: Valores negativos rotacionam ao longo de ambos os eixos ao mesmo tempo</li>
		</ul> 
		Os frames são salvos no arquivo com base na variavel de fps, por padrão ela salva a 10 fps, o que faz com que o vídeo seja gravado em "slow-motion".
		
		Para corrigir a gravação, precisamos comentar a linha que inverte a imagem:
		<pre><code class="python">
    #frame = cv.flip(frame, 0)
		</code></pre>
		E modificar a taxa de quadros por segundo para 30(valor encontrado experimentalmente):
		<pre><code class="python">
fps = 30.0
		</code></pre>
			<br><a href=https://github.com/CrakehallBoars/CrakehallBoars.github.io/blob/main/reports/report1/2D.py>Código Fonte Modificado</a>
		</p>

		<h3> Parte 3A </h3>
		<img src="f1.png" height="480">
		<img src="f2.png" height="480">
		<img src="f3.png" height="480">
		<h3> Parte 3B </h3>
		<h3> Parte 3C </h3>

		<br>
		<h2> 5. Conclusões e Comentários Finais</h2>
			<p>
Todos os exercícios foram interessantes de se fazer e com maneiras ainda mais interessantes de se concluir. 

Por mais simples que os programas fossem sempre tentamos dar um <em>"jeitinho"</em> de deixar mais desafiador e sempre tentar ao máximo realizar as tarefas com excelência e com um pouco mais do que nos foi pedido.

No primeiro exercício foi utilizado uma simples programação para simplesmente atender o que foi solicitado mas a partir do terceiro tentamos inovar e utilizar mais de nossos conhecimentos adquiridos ao longo de nossas vidas.

Utilizamos vários métodos para chegarmos ao resultado de uma maneira que fosse satisfatória para o grupo, e pedindo dicas ao professor para melhorar.

As tarefas foram simples, mais para o aprendizado, introdução da matéria e programação por trás de imagens e vídeos, mas com empenho nós aprendemos mais do que o exercício pedia.

Como vimos, podemos alterar a qualidade da imagem (desde a cor à resolução) e dos vídeos (os FPS's e como a imagem é mostrada) e com isso desenvolver técnicas para reproduzir imagens de uma maneira diferente do original e com isso podemos progredir ainda mais em nossos estudos.
		
			<p>
Fernando Suzuki: "O laboratório foi muito interessante porque introduziu conceitos que gosto bastante e a realização das atividades foi muito divertida." 
			</p>
		
			</p>

	<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
	<script>
		hljs.highlightAll();
	</script>
	</body>
</html>
